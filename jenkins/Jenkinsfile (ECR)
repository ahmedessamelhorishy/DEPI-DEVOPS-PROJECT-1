pipeline {
  agent any

  options {
    timestamps()
    ansiColor('xterm')
  }

  environment {
    AWS_ACCESS_KEY_ID     = credentials('aws-creds')
    AWS_SECRET_ACCESS_KEY = credentials('aws-creds')

    GITHUB_USERNAME   = "${env.GITHUB_USERNAME}"
    GITHUB_REPO       = "${env.GITHUB_REPO}"
    AWS_REGION        = "${env.AWS_REGION}"
    EKS_CLUSTER_NAME  = "${env.EKS_CLUSTER_NAME}"
    K8S_NAMESPACE     = "${env.K8S_NAMESPACE}"
    REGISTRY_HOST     = "${env.REGISTRY_HOST}"
    REGISTRY_REPO_URL = "${env.REGISTRY_REPO_URL}"

    FRONTEND_TAG      = "${env.REGISTRY_REPO_URL}:frontend-${env.BUILD_NUMBER}"
    BACKEND_TAG       = "${env.REGISTRY_REPO_URL}:backend-${env.BUILD_NUMBER}"
    DB_TAG            = "${env.REGISTRY_REPO_URL}:postgres-15"
  }

  triggers { githubPush() }

  stages {

    stage('Checkout') {
      steps {
        git branch: 'main', url: "https://github.com/${env.GITHUB_USERNAME}/${env.GITHUB_REPO}.git"
      }
    }

    stage('AWS EKS connect') {
      steps {
        sh 'set -e; aws eks update-kubeconfig --region "$AWS_REGION" --name "$EKS_CLUSTER_NAME"'
      }
    }

    stage('Create k8 namespace') {
      steps {
        sh 'set -e; kubectl create ns "$K8S_NAMESPACE" --dry-run=client -o yaml | kubectl apply -f -'
      }
    }

    stage('Docker login to ECR') {
      steps {
        sh '''
          set -e
          aws ecr get-login-password --region "$AWS_REGION" \
        | docker login --username AWS --password-stdin "$REGISTRY_HOST"
        '''
      }
    }

    stage('Push DB image to ECR (one-time)') {
      when {
        changeset "app/database/**"
        triggeredBy 'ManualTriggerCause'
      }
      steps {
        sh '''
          set -e
          if docker pull "${DB_TAG}" >/dev/null 2>&1; then
            echo "DB image already exists in ECR: ${DB_TAG}"
          else
            echo "Pushing DB image to ECR for first time"
            docker pull postgres:15
            docker tag postgres:15 "${DB_TAG}"
            docker push "${DB_TAG}"
          fi
        '''
      }
    }

    stage('Build, tag & push frontend') {
      when {
        changeset "app/frontend/**"
        triggeredBy 'ManualTriggerCause'
      }
      steps {
        sh '''
          set -e
          docker build -t frontend:build ./app/frontend
          docker tag frontend:build "$FRONTEND_TAG"
          docker tag frontend:build "$REGISTRY_HOST:frontend-latest"
          docker push "$FRONTEND_TAG"
          docker push "$REGISTRY_HOST:frontend-latest"
        '''
      }
    }

    stage('Build, tag & push backend') {
      when {
        changeset "app/backend/**"
        triggeredBy 'ManualTriggerCause'
      }
      steps {
        sh '''
          set -e
          docker build -t backend:build ./app/backend
          docker tag backend:build "$BACKEND_TAG"
          docker tag backend:build "$REGISTRY_HOST:backend-latest"
          docker push "$BACKEND_TAG"
          docker push "$REGISTRY_HOST:backend-latest"
        '''
      }
    }

    stage('Create Secret in Kubernetes for ECR') {
      steps {
        sh '''
          set -e
          kubectl -n "$K8S_NAMESPACE" create secret docker-registry cr-secret \
            --docker-server="${REGISTRY_HOST}" \
            --docker-username=AWS \
            --docker-password=$(aws ecr get-login-password --region "$AWS_REGION") \
            --docker-email="ae@hotmail.com" \
            --dry-run=client -o yaml | kubectl apply -f -
        '''
      }
    }

    stage('Deploy to Kubernetes') {
      when {
        anyOf {
          changeset "k8s/**"
          changeset "app/frontend/**"
          changeset "app/backend/**"
          changeset "app/database/**"
          triggeredBy 'ManualTriggerCause'
        }
      }
      steps {
        sh '''
          set -e
          kubectl -n "$K8S_NAMESPACE" apply -f k8s/db-configmap.yaml
          kubectl -n "$K8S_NAMESPACE" apply -f k8s/db-service.yaml
          kubectl -n "$K8S_NAMESPACE" apply -f k8s/backend-service.yaml
          kubectl -n "$K8S_NAMESPACE" apply -f k8s/frontend-service.yaml

          export FRONTEND_TAG BACKEND_TAG DB_TAG

          envsubst < k8s/db-deployment.yaml       | kubectl -n "$K8S_NAMESPACE" apply -f -
          envsubst < k8s/backend-deployment.yaml  | kubectl -n "$K8S_NAMESPACE" apply -f -
          envsubst < k8s/frontend-deployment.yaml | kubectl -n "$K8S_NAMESPACE" apply -f -

          kubectl -n "$K8S_NAMESPACE" rollout status deployment/db
          kubectl -n "$K8S_NAMESPACE" rollout status deployment/backend
          kubectl -n "$K8S_NAMESPACE" rollout status deployment/frontend
        '''
      }
    }
  }

  post {
    success {
      sh 'kubectl -n "$K8S_NAMESPACE" get svc frontend -o jsonpath="{.status.loadBalancer.ingress[0].hostname}"'
    }
    failure {
      echo 'Pipeline failed.'
    }
    always {
      echo 'Cleanup'
      sh '''
        set -e
        docker image prune -f
      '''
    }
  }
}